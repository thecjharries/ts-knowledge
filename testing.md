# Testing

## Stack

* [Mocha](//mochajs.org/) pulls everything together
* [Chai](//chaijs.com) adds some sugar
* [`chai-as-promised`](//github.com/domenic/chai-as-promised) adds promise support to Chai
* [Sinon](//sinonjs.org) adds powerful stubbing
* [Mockery](//github.com/mfncooper/mockery) allows `require` mocking on libraries like [`request`](//github.com/request/request)
* [nyc](//github.com/istanbuljs/nyc) provides code coverage (Its the [Istanbul](//istanbul.js.org) CLI)

```bash
npm install --save-dev \
    mocha @types/mocha mocha-typescript \
    chai @types/chai \
    chai-as-promised @types/chai-as-promised \
    sinon @types/sinon \
    mockery @types/mockery \
    nyc
```

## Config

### App Structure
```
coverage/ - Autogenerated by nyc
src/ - All source files
test/ - All specs, named *.spec.ts
    mocha.opts - The Mocha options file
package.json

```

### `package.json` (for `nyc`)

```json
{
    ...
    "nyc": {
        "include": [
          "src/**/*.ts"
        ],
        "extension": [
          ".ts"
        ],
        "require": [
          "ts-node/register"
        ],
        "reporter": [
          "json",
          "html",
          "text-summary"
        ],
        "all": true
    },
    ...
}
```

### `mocha.opts`

```
--recursive
--reporter spec
--ui mocha-typescript
--require source-map-support/register
--compilers ts:ts-node/register
--bail
--watch-extensions ts
```

## A Basic Test

### `src/TestableClass.ts`
```typescript
export class TestableClass {
    public returnFortySeven(): number {
        return 47;
    }

    public promiseToReturnFortySeven(): Promise<number> {
        return Promise.resolve(this.returnFortySeven());
    }
}
```
### `test/TestableClass.spec.ts`

#### Code
```typescript
// Things like ...be.true; or ...be.rejected; dont play nice with TSLint
/* tslint:disable:no-unused-expression */
import * as chai from "chai";
import * as sinon from "sinon";

// I personally use should.
// const assert = chai.assert;
const expect = chai.expect;
const should = chai.should();
/* tslint:disable-next-line:no-var-requires */
chai.use(require("chai-as-promised"));

import { TestableClass } from "../src/TestableClass";

describe("Testable class", () => {
    let testableClass: TestableClass | null;

    beforeEach(() => {
        testableClass = new TestableClass();
    });

    describe("returnFortySeven()", () => {
        it("should return 47", () => {
            const fortySeven: number = testableClass!.returnFortySeven();
            fortySeven.should.equal(47);
            fortySeven.should.be.a("number");
        });

    });

    describe("promiseToReturnFortySeven()", () => {
        describe("with vanilla chai", () => {
            it("should fulfill with 47", () => {
                const promisedFortySeven: Promise<number> = testableClass!.promiseToReturnFortySeven();
                promisedFortySeven.should.be.a("Promise");
                return promisedFortySeven
                    .then((result: number) => {
                        result.should.equal(47);
                    });
            });
        });

        describe("with chai-as-promised", () => {
            it("should fulfill with 47", () => {
                const promisedFortySeven: Promise<number> = testableClass!.promiseToReturnFortySeven();
                return promisedFortySeven.should.eventually.equal(47);
            });
        });

        describe("with a Sinon spy", () => {
            let returnFortySevenSpy: sinon.SinonSpy;

            beforeEach(() => {
                returnFortySevenSpy = sinon.spy(testableClass, "returnFortySeven");
            });

            it("should fulfill with 47", () => {
                const promisedFortySeven: Promise<number> = testableClass!.promiseToReturnFortySeven();
                return Promise.all([
                    promisedFortySeven.should.eventually.equal(47),
                    returnFortySevenSpy.calledOnce.should.be.true,
                ]);
            });

            afterEach(() => {
                returnFortySevenSpy.restore();
            });
        });

        describe("with a Sinon stub", () => {
            let returnFortySevenStub: sinon.SinonStub;

            beforeEach(() => {
                returnFortySevenStub = sinon.stub(testableClass, "returnFortySeven").returns(48);
            });

            it("should fulfill with 48", () => {
                const promisedFortySeven: Promise<number> = testableClass!.promiseToReturnFortySeven();
                return Promise.all([
                    promisedFortySeven.should.eventually.equal(48),
                    returnFortySevenStub.calledOnce.should.be.true,
                ]);
            });

            afterEach(() => {
                returnFortySevenStub.restore();
            });
        });

        describe("with a Sinon mock", () => {
            let returnFortySevenMock: sinon.SinonMock;

            beforeEach(() => {
                returnFortySevenMock = sinon.mock(testableClass);
                returnFortySevenMock.expects("returnFortySeven").once().returns(47);
            });

            it("should fulfill with the return of returnFortySeven", () => {
                const promisedFortySeven: Promise<number> = testableClass!.promiseToReturnFortySeven();
                return Promise.all([
                    promisedFortySeven.should.eventually.equal(47),
                    returnFortySevenMock.verify(),
                ]);
            });

            afterEach(() => {
                returnFortySevenMock.restore();
            });
        });
    });

    afterEach(() => {
        testableClass = null;
    });
});

```
#### Notes

* I've chosen to keep Sinon inside the `sinon` object instead of pulling its children out into the global scope. That's totally personal preference. Because I'm mixing and matching several different testing libraries, I feel like the code is more readable when you know where the methods are coming from.
```typescript
// This
import * as sinon from "sinon";
// instead of this
import { mock, SinonMock, SinonSpy, SinonStub, spy, stub } from "sinon";
```
* `testableClass` is type `TestableClass | null` (a [union type](//www.typescriptlang.org/docs/handbook/advanced-types.html#union-types)) because my `tsconfig.json` has `strictNullChecks` turned on. While it's not necessary, I've found that it's more expressive to do it this way, and it's easier for non-JS devs to follow.
* `testableClass` methods are called via `testableClass!.methodName`. `!` (in this context) is the [non-null assertion operator](//www.typescriptlang.org/docs/handbook/advanced-types.html#type-guards-and-type-assertions), which is necessary to let the compiler know that `testableClass` isn't `null` here. Granted, it would be simpler to just turn off `strictNullChecks`, but now anyone reading the code knows `testableClass` is explicitly not null here. Maintenance is easier when code is not ambiguous.
* Tests that rely on promises must return [the promise chain](//mochajs.org/#working-with-promises).
* [Sinon `spy`s](//sinonjs.org/releases/v2.2.0/spies/) are passive method watchers. They record information about the call without touching the call itself. They can replace a method in code or be passed as a callback to something else.
* [Sinon `stub`s](//sinonjs.org/releases/v2.2.0/stubs/) are active method replacements. They allow you to replace any method with with your desired logic. The docs list many great ideas, including different behaviors for multiple calls or different arguments.
* [Sinon `mock`s](//sinonjs.org/releases/v2.2.0/mocks/) are passive method watchers with expectations. Mocks define expectations up front, instead of after as with assertions.