# Testing

## Stack

* [Mocha](//mochajs.org/) pulls everything together
* [Chai](//chaijs.com) adds some sugar
* [`chai-as-promised`](//github.com/domenic/chai-as-promised) adds promise support to Chai
* [Sinon](//sinonjs.org) adds powerful stubbing
* [Mockery](//github.com/mfncooper/mockery) allows `require` mocking on libraries like [`request`](//github.com/request/request)
* [nyc](//github.com/istanbuljs/nyc) provides code coverage (Its the [Istanbul](//istanbul.js.org) CLI)

```bash
npm install --save-dev \
    mocha @types/mocha mocha-typescript \
    chai @types/chai \
    chai-as-promised @types/chai-as-promised \
    sinon @types/sinon \
    mockery @types/mockery \
    nyc
```

## Config

### App Structure
```
coverage/ - Autogenerated by nyc
src/ - All source files
test/ - All specs, named *.spec.ts
    mocha.opts - The Mocha options file
package.json

```

### `package.json` (for `nyc`)

```json
{
    ...
    "nyc": {
        "include": [
          "src/**/*.ts"
        ],
        "extension": [
          ".ts"
        ],
        "require": [
          "ts-node/register"
        ],
        "reporter": [
          "json",
          "html",
          "text-summary"
        ],
        "all": true
    },
    ...
}
```

### `mocha.opts`

```
--recursive
--reporter spec
--ui mocha-typescript
--require source-map-support/register
--compilers ts:ts-node/register
--bail
--watch-extensions ts
```

## A Basic Test

### `src/TestableClass.ts`
```typescript
export class TestableClass {
    public returnFortySeven(): number {
        return 47;
    }

    public promiseToReturnFortySeven(): Promise<number> {
        return Promise.resolve(this.returnFortySeven());
    }
}
```
### `test/TestableClass.spec.ts`

#### Code
```typescript
// Things like ...be.true; or ...be.rejected; dont play nice with TSLint
/* tslint:disable:no-unused-expression */

import * as chai from "chai";
import * as sinon from "sinon";

// I personally use should.
const expect = chai.expect;
const should = chai.should();
/* tslint:disable-next-line:no-var-requires */
chai.use(require("chai-as-promised"));

import { TestableClass } from "../src/TestableClass";

// Describe a single class
describe("Testable class", () => {
    let testableClass: TestableClass | null;

    // Create new instance of TestableClass each run
    beforeEach(() => {
        testableClass = new TestableClass();
    });

    // Describe the tests for a single method
    describe("returnFortySeven()", () => {
        // It only does one thing
        it("should return 47", () => {
            const fortySeven: number = testableClass!.returnFortySeven();
            // Redundant assertions aren't necessarily bad
            fortySeven.should.equal(47);
            fortySeven.should.be.a("number");
        });
    });

    // Describe the tests for another method
    describe("promiseToReturnFortySeven()", () => {
        // Nest into some other condition
        describe("with vanilla chai", () => {
            // Vanilla chai assertions have to run after the promise is fulfilled
            it("should fulfill with 47", () => {
                const promisedFortySeven: Promise<number> = testableClass!.promiseToReturnFortySeven();
                promisedFortySeven.should.be.a("Promise");
                return promisedFortySeven
                    .then((result: number) => {
                        result.should.equal(47);
                    });
            });
        });

        // chai-as-promised handles the promise for you
        describe("with chai-as-promised", () => {
            it("should fulfill with 47", () => {
                const promisedFortySeven: Promise<number> = testableClass!.promiseToReturnFortySeven();
                return promisedFortySeven.should.eventually.equal(47);
            });
        });

        describe("with a Sinon spy", () => {
            // Declare the spy in the outer context
            let returnFortySevenSpy: sinon.SinonSpy;

            // Rebuild the spy each test
            beforeEach(() => {
                returnFortySevenSpy = sinon.spy(testableClass, "returnFortySeven");
            });

            // Ensure the spy was called
            it("should fulfill with 47", () => {
                const promisedFortySeven: Promise<number> = testableClass!.promiseToReturnFortySeven();
                return Promise.all([
                    promisedFortySeven.should.eventually.equal(47),
                    returnFortySevenSpy.calledOnce.should.be.true,
                ]);
            });

            // Return the spy to its original method
            afterEach(() => {
                returnFortySevenSpy.restore();
            });
        });

        describe("with a Sinon stub", () => {
            // Declare the stub in the outer context
            let returnFortySevenStub: sinon.SinonStub;

            // Rebuild the stub each test
            // Change the behavior of the stub
            beforeEach(() => {
                returnFortySevenStub = sinon.stub(testableClass, "returnFortySeven");
                returnFortySevenStub.returns(48);
            });

            // Ensure the stub was called
            it("should fulfill with 48", () => {
                const promisedFortySeven: Promise<number> = testableClass!.promiseToReturnFortySeven();
                return Promise.all([
                    promisedFortySeven.should.eventually.equal(48),
                    returnFortySevenStub.calledOnce.should.be.true,
                ]);
            });

            // Return the stub to its original method
            afterEach(() => {
                returnFortySevenStub.restore();
            });
        });

        describe("with a Sinon mock", () => {
            // Declare the mock in the outer context
            let returnFortySevenMock: sinon.SinonMock;

            // Rebuild the mock each test
            beforeEach(() => {
                returnFortySevenMock = sinon.mock(testableClass);
                returnFortySevenMock.expects("returnFortySeven").once().returns(47);
            });

            // Ensure the mock was called
            it("should fulfill with the return of returnFortySeven", () => {
                const promisedFortySeven: Promise<number> = testableClass!.promiseToReturnFortySeven();
                return Promise.all([
                    promisedFortySeven.should.eventually.equal(47),
                    returnFortySevenMock.verify(),
                ]);
            });

            // Return the mock to its original method
            afterEach(() => {
                returnFortySevenMock.restore();
            });
        });
    });

    // Wipe testableClass after each class
    afterEach(() => {
        testableClass = null;
    });
});
```
#### Notes

* I've chosen to keep Sinon inside the `sinon` object instead of pulling its children out into the global scope. That's totally personal preference. Because I'm mixing and matching several different testing libraries, I feel like the code is more readable when you know where the methods are coming from.
```typescript
// This
import * as sinon from "sinon";
// instead of this
import { mock, SinonMock, SinonSpy, SinonStub, spy, stub } from "sinon";
```
* `testableClass` is type `TestableClass | null` (a [union type](//www.typescriptlang.org/docs/handbook/advanced-types.html#union-types)) because my `tsconfig.json` has `strictNullChecks` turned on. While it's not necessary, I've found that it's more expressive to do it this way, and it's easier for non-JS devs to follow.
* `testableClass` methods are called via `testableClass!.methodName`. `!` (in this context) is the [non-null assertion operator](//www.typescriptlang.org/docs/handbook/advanced-types.html#type-guards-and-type-assertions), which is necessary to let the compiler know that `testableClass` isn't `null` here. Granted, it would be simpler to just turn off `strictNullChecks`, but now anyone reading the code knows `testableClass` is explicitly not null here. Maintenance is easier when code is not ambiguous.
* Tests that rely on promises must return [the promise chain](//mochajs.org/#working-with-promises).
* [Sinon `spy`s](//sinonjs.org/releases/v2.2.0/spies/) are passive method watchers. They record information about the call without touching the call itself. They can replace a method in code or be passed as a callback to something else.
* [Sinon `stub`s](//sinonjs.org/releases/v2.2.0/stubs/) are active method replacements. They allow you to replace any method with with your desired logic. The docs list many great ideas, including different behaviors for multiple calls or different arguments.
* [Sinon `mock`s](//sinonjs.org/releases/v2.2.0/mocks/) are passive method watchers with expectations. Mocks define expectations up front, instead of after as with assertions.

## Mocking Global Functions

Preview:

Use `typeof` and `mockery`

## Mocking `console`

Preview:

Stub in `beforeEach`, `restore` before assertions. If you can't `restore` before assertions, you're probably SOL.

## Code Coverage with `nyc`

Preview:

Just read the output.
